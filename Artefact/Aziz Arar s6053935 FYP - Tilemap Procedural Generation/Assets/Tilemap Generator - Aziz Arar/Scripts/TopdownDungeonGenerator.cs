using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Tilemaps;

public class TopdownDungeonGenerator : TilemapGenerator
{


    [Header("Tiles")]
    [SerializeField] public TileBase Floor;
    [SerializeField] public TileBase BG;
    [SerializeField] public TileBase Wall;

    public bool GenerateWalls = false;

    [Header("BSP Settings")]
    public int minRoomSize = 5;
    public int maxRoomSize = 20;

    public class Leaf
    {
        /*
        Create a Leaf
        Each Leaf will have a left and right leaf inside of it, these will split up into new leaves creating a tree.
        When it reaches the smallest leaf, left or right respectively will remain null and end the tree there.
         */
        public Leaf leftLeaf, rightLeaf;
        public Rect roomRect;
        public Rect room = new Rect(-1, -1, 0, 0);




        public Rect getLeaf()
        {
            if (leftLeaf == null && rightLeaf == null)
            {
                return room;
            }
            if (leftLeaf != null)
            {
                Rect lroom = leftLeaf.getLeaf();
                if (lroom.x != -1)
                    return lroom;
            }
            if (rightLeaf != null)
            {
                Rect rroom = rightLeaf.getLeaf();
                if (rroom.x != -1)
                    return rroom;
            }

            return new Rect(-1, -1, 0, 0);
        }

        public void GenerateRoom()
        {
            if (leftLeaf != null)
            {
                leftLeaf.GenerateRoom();
            }
            if (rightLeaf != null)
            {
                rightLeaf.GenerateRoom();
            }
            if (leftLeaf == null && rightLeaf == null)
            {
                int roomWidth = (int)Random.Range(roomRect.width / 2, roomRect.width - 2);
                int roomHeight = (int)Random.Range(roomRect.height / 2, roomRect.height - 2);
                int roomX = (int)Random.Range(1, roomRect.width - roomWidth - 1);
                int roomY = (int)Random.Range(1, roomRect.height - roomHeight - 1);

                room = new Rect(roomRect.x + roomX, roomRect.y + roomY, roomWidth, roomHeight);

            }
        }

        public Leaf(Rect newRect)
        {
            roomRect = newRect;

        }

        public bool LeafSplit(int minRoomSize, int maxRoomSize)
        {
            /*
            This function splits the dungeon Horizontally or Vertically depending on the size of the subdungeons.
            Once split, make these splits new leaves in the tree.
            The size of the rooms will be affected by the minimum
            
             */
            if (leftLeaf != null && rightLeaf != null)
            {
                return false;
            }

            bool horizontalSplit;
            if (roomRect.width / roomRect.height >= 1.25)
                horizontalSplit = false;

            else if (roomRect.height / roomRect.width >= 1.25)
                horizontalSplit = true;

            else
                horizontalSplit = Random.Range(0.0f, 1.0f) > 0.5;

            if (Mathf.Min(roomRect.height, roomRect.width) / 2 < minRoomSize)
                return false;

            if (horizontalSplit)
            {

                int splitLeaf = Random.Range(minRoomSize, (int)(roomRect.width - minRoomSize));

                leftLeaf = new Leaf(new Rect(roomRect.x, roomRect.y, roomRect.width, splitLeaf));
                rightLeaf = new Leaf(
                new Rect(roomRect.x, roomRect.y + splitLeaf, roomRect.width, roomRect.height - splitLeaf));
            }
            else
            {
                int splitLeaf = Random.Range(minRoomSize, (int)(roomRect.height - minRoomSize));

                leftLeaf = new Leaf(new Rect(roomRect.x, roomRect.y, splitLeaf, roomRect.height));
                rightLeaf = new Leaf(
                new Rect(roomRect.x + splitLeaf, roomRect.y, roomRect.width - splitLeaf, roomRect.height));
            }

            return true;
        }
    }



    // Use this for initialization
    void Start()
    {
        thisMap = GetComponent<Tilemap>();
        arrayLength = gridX * gridY;
        positions = new Vector3Int[arrayLength];
        tileArray = new TileBase[arrayLength];

        SetupDungeon();
        Leaf currentDungeon = new Leaf(new Rect(0, 0, gridX, gridY));
        BSP(currentDungeon);
        currentDungeon.GenerateRoom();
        DrawRooms(currentDungeon);


        if (GenerateCollisionLayer)
        {
            GenerateCollisions();
        }

        if (GenerateWalls)
            PlaceWalls();


    }
    private void SetupDungeon()
    {
        /*
         Set up the dungeon by placing a BG Tile on every tile on the grid. 
         We can directly draw new tiles generated by the BSP Ontop. 
         Additionally, This allows us to easily recall this to wipe the level on Regeneration.
         */
        for (int index = 0; index < arrayLength; ++index)
        {
            positions[index] = new Vector3Int(index % (gridX), index / (gridY), 0);
            positions[index].x = index % gridX;
            positions[index].y = index / gridY;
            tileArray[index] = BG;

        }
        thisMap.SetTiles(positions, tileArray);
    }
    public void BSP(Leaf dungeonLeaf)
    {
        /*
         Begin the BSP Generation
         If the current dungeon size is bigger then the max room size, start splitting it
         Once Split, Run this again on the split dungeons
         */
        if (dungeonLeaf.leftLeaf == null && dungeonLeaf.rightLeaf == null)
        {
            if (dungeonLeaf.roomRect.width > maxRoomSize || dungeonLeaf.roomRect.height > maxRoomSize || Random.Range(0.0f, 1.0f) > 0.25)
            {
                if (dungeonLeaf.LeafSplit(minRoomSize, maxRoomSize))
                {
                    BSP(dungeonLeaf.leftLeaf);

                }
            }
        }
    }
    public void CorridorCreation(Leaf left, Leaf right)
    {
        /*
         The purpose of this function is to connect leaflets, a point in each leaf is obtained
         This code then begins placing tiles between them.
         */
        Rect lroom = left.getLeaf();
        Rect rroom = right.getLeaf();
        
        Vector2 point1 = new Vector2((int)Random.Range(lroom.x + 1, lroom.xMax), (int)Random.Range(lroom.y + 1, lroom.yMax - 1));
        Vector2 point2 = new Vector2((int)Random.Range(rroom.x + 1, rroom.xMax), (int)Random.Range(rroom.y + 1, rroom.yMax - 1));

        //Ensure the largest value is to the right
        if (point1.x > point2.x)
        {
            Vector2 temp = point1;
            point1 = point2;
            point2 = temp;
        }

        int w = (int)(point1.x - point2.x);
        int h = (int)(point1.y - point2.y);

        if (w != 0)
        {


            if (Random.Range(0, 1) > 2)
            {
                //For each tile in the range of the point, to the max size, place a tile down
                for (int i = (int)point1.x; i < (int)point1.x + Mathf.Abs(w) + 1; i++)
                    for (int j = (int)point1.y; j < (int)point1.y + 1; j++)
                    {
                        thisMap.SetTile(new Vector3Int(i, j, 0), Floor);
                    }


                if (h < 0)
                {
                    for (int i = (int)point2.x; i < point2.x + 1; i++)
                        for (int j = (int)point1.y; j < (int)point1.y + Mathf.Abs(h); j++)
                        {
                            thisMap.SetTile(new Vector3Int(i, j, 0), Floor);
                        }

                }
                else
                {
                    for (int i = (int)point2.x; i < (int)point2.x + 1; i++)
                        for (int j = (int)point1.y; j < (int)point1.y - Mathf.Abs(h); j++)
                        {
                            thisMap.SetTile(new Vector3Int(i, j, 0), Floor);
                        }

                }

            }

            else
            {
                if (h < 0)
                {
                    for (int i = (int)point1.x; i < (int)point1.x + 1; i++)
                        for (int j = (int)point1.y; j < (int)point1.y + Mathf.Abs(h); j++)
                        {
                            thisMap.SetTile(new Vector3Int(i, j, 0), Floor);
                        }

                }
                else
                {
                    for (int i = (int)point1.x; i < (int)point1.x + 1; i++)
                        for (int j = (int)point2.y; j < (int)point2.y + Mathf.Abs(h); j++)
                        {
                            thisMap.SetTile(new Vector3Int(i, j, 0), Floor);
                        }

                }
            }

            for(int i = (int)point1.x; i < (int)point1.x + Mathf.Abs(w) + 1; i++)
                for (int j = (int)point2.y; j < (int)point2.y + 1; j++)
                {
                    thisMap.SetTile(new Vector3Int(i, j, 0), Floor);
                }

        }

        else
        {
            if (h < 0)
            {
                for (int i = (int)point1.x; i < (int)point1.x + 1; i++)
                    for (int j = (int)point1.y; j < (int)point1.y + Mathf.Abs(h); j++)
                    {
                        thisMap.SetTile(new Vector3Int(i, j, 0), Floor);
                    }
            }
            else
            {
                for (int i = (int)point2.x; i < (int)point2.x + 1; i++)
                    for (int j = (int)point2.y; j < (int)point2.y + Mathf.Abs(h); j++)
                    {
                        thisMap.SetTile(new Vector3Int(i, j, 0), Floor);
                    }
            }
        }



    }
    public void DrawRooms(Leaf dungeonLeaf)
    {

        /*
         Checks if the Leaf is the final leaf, this is known if the left and right variables are null.
         If so, draw the tile.
         If not, attempt to draw the leaves of left and right to find a final leaf to draw.
         While attempting to draw the newer leaves, if they both contain leaves inside of them, connect them with a Corridor.

         To do: Remove Rects and make based off TileBase
         */
        if (dungeonLeaf == null)
        {
            return;
        }
        if (dungeonLeaf.leftLeaf == null && dungeonLeaf.rightLeaf == null)
        {


            for (int i = (int)dungeonLeaf.room.x; i < dungeonLeaf.room.xMax; i++)
            {
                for (int j = (int)dungeonLeaf.room.y; j < dungeonLeaf.room.yMax; j++)
                {


                    thisMap.SetTile(new Vector3Int(i, j, 0), Floor);


                }
            }



        }
        else
        {
            DrawRooms(dungeonLeaf.leftLeaf);
            DrawRooms(dungeonLeaf.rightLeaf);

            if (dungeonLeaf.leftLeaf != null && dungeonLeaf.rightLeaf != null)
                CorridorCreation(dungeonLeaf.leftLeaf, dungeonLeaf.rightLeaf);
        }
    }

    private void PlaceWalls()
    {

        //Place a Wall if enabled, this will be replace any BG Tile that is placed directly above a floor tile.
        for (int i = 0; i < gridX; i++)
            for (int j = 0; j < gridY; j++)
            {
                if (thisMap.GetTile(new Vector3Int(i, j, 0)) == Floor)
                {
                    if (thisMap.GetTile(new Vector3Int(i, j + 1, 0)) == BG)
                    {
                        thisMap.SetTile(new Vector3Int(i, j + 1, 0), Wall);
                    }
                }
            }
    }
    protected override void GenerateCollisions()
    {
        GameObject collisionMap = new GameObject("CollisionMap", typeof(Tilemap));
        collisionMap.GetComponent<Transform>().SetParent(thisMap.GetComponentInParent<Grid>().transform);

        for (int i = 0; i < gridX; i++)
            for (int j = 0; j < gridY; j++)
            {
                if (thisMap.GetTile(new Vector3Int(i, j, 0)) == BG)
                {
                    collisionMap.GetComponent<Tilemap>().SetTile(new Vector3Int(i, j, 0), Floor);
                }
            }

        collisionMap.AddComponent<TilemapCollider2D>();
        collisionMap.GetComponent<TilemapCollider2D>().usedByComposite = true;
        collisionMap.AddComponent<Rigidbody2D>();
        collisionMap.GetComponent<Rigidbody2D>().isKinematic = true;
        collisionMap.AddComponent<CompositeCollider2D>();
    }
    public override void Regenerate()
    {
        SetupDungeon();
        Leaf newDungeon = new Leaf(new Rect(0, 0, gridX, gridY));
        BSP(newDungeon);
        newDungeon.GenerateRoom();
        DrawRooms(newDungeon);

        if (GenerateCollisionLayer)
        {
            GameObject.Destroy(GameObject.Find("CollisionMap"));
            GenerateCollisions();
        }

        if (GenerateWalls)
            PlaceWalls();

    }

    //References to BSP assitance, applying the algoritm with changes to the Tilemap
    //http://www.rombdn.com/blog/2018/01/12/random-dungeon-bsp-unity/
    //https://eskerda.com/bsp-dungeon-generation/
    //https://gamedevelopment.tutsplus.com/tutorials/how-to-use-bsp-trees-to-generate-game-maps--gamedev-12268

}

