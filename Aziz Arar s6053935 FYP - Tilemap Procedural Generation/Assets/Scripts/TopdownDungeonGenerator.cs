using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Tilemaps;

public class TopdownDungeonGenerator : TilemapGenerator
{


    [Header("Tiles")]
    [SerializeField] public TileBase Floor;
    [SerializeField] public TileBase BG;
    [SerializeField] public TileBase Wall;

    public bool GenerateWalls = false;

    [Header("BSP Settings")]
    public int minRoomSize = 5;
    public int maxRoomSize = 20;
    private List<Rect> CorridorList = new List<Rect>();


    public class Leaf
    {
        /*
        Create a Leaf
        Each Leaf will have a left and right leaf inside of it, these will split up into new leaves creating a tree.
        When it reaches the smallest leaf, left or right respectively will remain null and end the tree there.
         */
        public Leaf left, right;
        public Rect rect;
        public Rect room = new Rect(-1, -1, 0, 0);




        public Rect GetRoom()
        {
            if (left == null && right == null)
            {
                return room;
            }
            if (left != null)
            {
                Rect lroom = left.GetRoom();
                if (lroom.x != -1)
                    return lroom;
            }
            if (right != null)
            {
                Rect rroom = right.GetRoom();
                if (rroom.x != -1)
                    return rroom;
            }

            return new Rect(-1, -1, 0, 0);
        }

        public void CreateRoom()
        {
            if (left != null)
            {
                left.CreateRoom();
            }
            if (right != null)
            {
                right.CreateRoom();
            }
            if (left == null && right == null)
            {
                int roomWidth = (int)Random.Range(rect.width / 2, rect.width - 2);
                int roomHeight = (int)Random.Range(rect.height / 2, rect.height - 2);
                int roomX = (int)Random.Range(1, rect.width - roomWidth - 1);
                int roomY = (int)Random.Range(1, rect.height - roomHeight - 1);

                room = new Rect(rect.x + roomX, rect.y + roomY, roomWidth, roomHeight);

            }
        }

        public Leaf(Rect mrect)
        {
            rect = mrect;

        }

        public bool Split(int minRoomSize, int maxRoomSize)
        {
            /*
            This function splits the dungeon Horizontally or Vertically depending on the size of the subdungeons.
            Once split, make these splits new leaves in the tree.
            The size of the rooms will be affected by the minimum
            
             */
            if (left != null && right != null)
            {
                return false;
            }

            bool splitH;
            if (rect.width / rect.height >= 1.25)
            {
                splitH = false;
            }
            else if (rect.height / rect.width >= 1.25)
            {
                splitH = true;
            }
            else
            {
                splitH = Random.Range(0.0f, 1.0f) > 0.5;
            }

            if (Mathf.Min(rect.height, rect.width) / 2 < minRoomSize)
            {

                return false;
            }
            if (splitH)
            {

                int split = Random.Range(minRoomSize, (int)(rect.width - minRoomSize));

                left = new Leaf(new Rect(rect.x, rect.y, rect.width, split));
                right = new Leaf(
                  new Rect(rect.x, rect.y + split, rect.width, rect.height - split));
            }
            else
            {
                int split = Random.Range(minRoomSize, (int)(rect.height - minRoomSize));

                left = new Leaf(new Rect(rect.x, rect.y, split, rect.height));
                right = new Leaf(
                  new Rect(rect.x + split, rect.y, rect.width - split, rect.height));
            }

            return true;
        }
    }



    // Use this for initialization
    void Start()
    {
        CorridorList = new List<Rect>();
        thisMap = GetComponent<Tilemap>();
        arrayLength = gridX * gridY;
        positions = new Vector3Int[arrayLength];
        tileArray = new TileBase[arrayLength];

        SetupDungeon();
        Leaf currentDungeon = new Leaf(new Rect(0, 0, gridX, gridY));
        CreateBSP(currentDungeon);
        currentDungeon.CreateRoom();
        DrawRooms(currentDungeon);
        DrawCorridors();


        if (GenerateCollisionLayer)
        {
            GenerateCollisions();
        }

        if (GenerateWalls)
            PlaceWalls();


    }

    private void SetupDungeon()
    {
        /*
         Set up the dungeon by placing a BG Tile on every tile on the grid. 
         We can directly draw new tiles generated by the BSP Ontop. 
         Additionally, This allows us to easily recall this to wipe the level on Regeneration.
         */
        for (int index = 0; index < arrayLength; ++index)
        {
            positions[index] = new Vector3Int(index % (gridX), index / (gridY), 0);
            positions[index].x = index % gridX;
            positions[index].y = index / gridY;
            tileArray[index] = BG;

        }
        thisMap.SetTiles(positions, tileArray);
    }
    public void CreateBSP(Leaf dungeonLeaf)
    {
        /*
         Begin the BSP Generation
         If the current dungeon size is bigger then the max room size, start splitting it
         Once Split, Run this again on the split dungeons
         */
        if (dungeonLeaf.left == null && dungeonLeaf.right == null)
        {
            
            if (dungeonLeaf.rect.width > maxRoomSize
              || dungeonLeaf.rect.height > maxRoomSize
              || Random.Range(0.0f, 1.0f) > 0.25)
            {

                if (dungeonLeaf.Split(minRoomSize, maxRoomSize))
                {

                    CreateBSP(dungeonLeaf.left);
                    CreateBSP(dungeonLeaf.right);


                }
            }
        }
    }
    public void CorridorCreation(Leaf left, Leaf right)
    {
        Rect lroom = left.GetRoom();
        Rect rroom = right.GetRoom();


        Vector2 lpoint = new Vector2((int)Random.Range(lroom.x + 1, lroom.xMax), (int)Random.Range(lroom.y + 1, lroom.yMax - 1));
        Vector2 rpoint = new Vector2((int)Random.Range(rroom.x + 1, rroom.xMax), (int)Random.Range(rroom.y + 1, rroom.yMax - 1));

        if (lpoint.x > rpoint.x)
        {
            Vector2 temp = lpoint;
            lpoint = rpoint;
            rpoint = temp;
        }

        int w = (int)(lpoint.x - rpoint.x);
        int h = (int)(lpoint.y - rpoint.y);

        if (w != 0)
        {


            if (Random.Range(0, 1) > 2)
            {

                CorridorList.Add(new Rect(lpoint.x, lpoint.y, Mathf.Abs(w) + 1, 1));

                if (h < 0)
                {

                    CorridorList.Add(new Rect(rpoint.x, lpoint.y, 1, Mathf.Abs(h)));
                }
                else
                {

                    CorridorList.Add(new Rect(rpoint.x, lpoint.y, 1, -Mathf.Abs(h)));
                }

            }

            else
            {
                if (h < 0)
                {

                    CorridorList.Add(new Rect(lpoint.x, lpoint.y, 1, Mathf.Abs(h)));
                }
                else
                {

                    CorridorList.Add(new Rect(lpoint.x, rpoint.y, 1, Mathf.Abs(h)));
                }
            }

            CorridorList.Add(new Rect(lpoint.x, rpoint.y, Mathf.Abs(w) + 1, 1));

        }

        else
        {
            if (h < 0)
            {

                CorridorList.Add(new Rect((int)lpoint.x, (int)lpoint.y, 1, Mathf.Abs(h)));
            }
            else
            {

                CorridorList.Add(new Rect((int)rpoint.x, (int)rpoint.y, 1, Mathf.Abs(h)));
            }
        }



    }
    public void DrawRooms(Leaf dungeonLeaf)
    {

        /*
         Checks if the Leaf is the final leaf, this is known if the left and right variables are null.
         If so, draw the tile.
         If not, attempt to draw the leaves of left and right to find a final leaf to draw.
         While attempting to draw the newer leaves, if they both contain leaves inside of them, connect them with a Corridor.
         */
        if (dungeonLeaf == null)
        {
            return;
        }
        if (dungeonLeaf.left == null && dungeonLeaf.right == null)
        {


            for (int i = (int)dungeonLeaf.room.x; i < dungeonLeaf.room.xMax; i++)
            {
                for (int j = (int)dungeonLeaf.room.y; j < dungeonLeaf.room.yMax; j++)
                {

                    
                    thisMap.SetTile(new Vector3Int(i, j, 0), Floor);
                     

                }
            }



        }
        else
        {
            DrawRooms(dungeonLeaf.left);
            DrawRooms(dungeonLeaf.right);

            if (dungeonLeaf.left != null && dungeonLeaf.right != null)
                CorridorCreation(dungeonLeaf.left, dungeonLeaf.right);
        }
    }
    public void DrawCorridors()
    {
        //For every Corridor Rect collected in CorridorCreation(), draw it
        foreach (Rect c in CorridorList)
        {
            for (int i = (int)c.x; i < c.xMax; i++)
            {
                for (int j = (int)c.y; j < c.yMax; j++)
                {
                    thisMap.SetTile(new Vector3Int(i, j, 0), Floor);

                }
            }
        }
    }
    private void PlaceWalls()
    {

        //Place a Wall if enabled, this will be replace any BG Tile that is placed directly above a floor tile.
        for (int i = 0; i < gridX; i++)
            for (int j = 0; j < gridY; j++)
            {
                if (thisMap.GetTile(new Vector3Int(i, j, 0)) == Floor)
                {
                    if (thisMap.GetTile(new Vector3Int(i, j + 1, 0)) == BG)
                    {
                        thisMap.SetTile(new Vector3Int(i, j + 1, 0), Wall);
                    }
                }
            }
    }
    protected override void GenerateCollisions()
    {
        GameObject collisionMap = new GameObject("CollisionMap", typeof(Tilemap));
        collisionMap.GetComponent<Transform>().SetParent(thisMap.GetComponentInParent<Grid>().transform);

        for (int i = 0; i < gridX; i++)
            for (int j = 0; j < gridY; j++)
            {
                if (thisMap.GetTile(new Vector3Int(i, j, 0)) == BG)
                {
                    collisionMap.GetComponent<Tilemap>().SetTile(new Vector3Int(i, j, 0), Floor);
                }
            }

        collisionMap.AddComponent<TilemapCollider2D>();
        collisionMap.GetComponent<TilemapCollider2D>().usedByComposite = true;
        collisionMap.AddComponent<Rigidbody2D>();
        collisionMap.GetComponent<Rigidbody2D>().isKinematic = true;
        collisionMap.AddComponent<CompositeCollider2D>();
    }
    public override void Regenerate()
    {
        CorridorList.Clear();
        SetupDungeon();
        Leaf newDungeon = new Leaf(new Rect(0, 0, gridX, gridY));
        CreateBSP(newDungeon);
        newDungeon.CreateRoom();
        DrawRooms(newDungeon);
        DrawCorridors();

        if (GenerateCollisionLayer)
        {
            GameObject.Destroy(GameObject.Find("CollisionMap"));
            GenerateCollisions();
        }

        if (GenerateWalls)
            PlaceWalls();

    }


    //http://www.rombdn.com/blog/2018/01/12/random-dungeon-bsp-unity/
    //https://eskerda.com/bsp-dungeon-generation/
}

